<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Recipe Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .recipe-card {
            page-break-inside: avoid;
        }
    </style>
</head>

<body class="bg-gray-900 text-white min-h-screen antialiased p-4 sm:p-6 md:p-8">

    <div class="w-full max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-white tracking-tight">Unit Recipe Generator</h1>
            <p id="loading-status" class="mt-2 text-lg text-yellow-400">Loading rate data...</p>
        </header>

        <div class="bg-gray-800 p-6 rounded-xl shadow-lg mb-8 max-w-2xl mx-auto">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 items-end">
                <div class="md:col-span-2">
                    <label for="brand-select" class="block text-sm font-medium text-gray-300 mb-1">Select Brand</label>
                    <select id="brand-select"
                        class="w-full bg-gray-700 text-white border-gray-600 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 p-3">
                        <option value="Parx">Parx</option>
                        <option value="Park Avenue">Park Avenue</option>
                        <option value="Ready to Wear">Ready to Wear</option>
                        <option value="ColorPlus">ColorPlus</option>
                    </select>
                </div>
                <button type="button" id="generate-btn" disabled
                    class="w-full bg-blue-800 text-gray-400 font-bold py-3 px-4 rounded-lg shadow-md cursor-not-allowed">
                    Loading...
                </button>
            </div>
        </div>

        <div id="recipes-output" class="space-y-8">
        </div>

    </div>

    <script>
        // --- CONSTANTS & GLOBAL DATA ---
        const SQMM_TO_SQFT = (1 / 304.8) * (1 / 304.8);
        const MM_TO_FT = 1 / 304.8;
        let RATE_DATA_BY_BRAND = {};
        let RAW_MATERIAL_RATES = {};

        // Mapping from CSV Item name to BOM Item name (handles plurals, etc.)
        const CSV_TO_BOM_ITEM_MAP = {
            "SIDE PORTAL": "Side Portals",
            "BACK PANEL": "Back Panels",
            "SHELVE": "Shelves",
            "DRAWER": "Drawers",
            "HEADER": "Header",
            "CHANNEL": "Channels",
            "PLINTH": "Plinth",
            "STRAIGHT ARM": "Straight Arm",
            "BACKBAR": "Backbar",
            "SHELF BRACKET": "Shelf Bracket"
        };


        // --- BILL OF MATERIALS CONFIGURATION (ALL BRANDS) ---
        const getBomData = () => ({
            "Parx": {
                materials: [
                    { item: "18mm MDF OSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_OSL_OWHITE, wastage: 15, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : (f.item === 'Drawers' ? (f.l * f.w) + (f.l * f.h) : 0) * SQMM_TO_SQFT },
                    { item: "18mm MDF BSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE, wastage: 15, calculateBaseQty: (f) => { let a = 0; if (f.item === 'Back Panels') a = (f.l * f.h); if (f.item === 'Drawers') a = (2 * f.w * f.h) + (f.l * f.h); if (f.item === 'Shelves') a = (f.l * f.w); return a * SQMM_TO_SQFT; } },
                    { item: "25mm MDF BSL (for Duco Pattern)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_25_BSL_DUCO, wastage: 15, calculateBaseQty: (f) => (['Header', 'Side Portals'].includes(f.item) && f.l >= 50) ? (f.l * f.h) * SQMM_TO_SQFT : 0 },
                    { item: "Light Blue Laminate (1mm)", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_LIGHT_BLUE, wastage: 15, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : (f.item === 'Drawers' ? (f.l * f.w) + (f.l * f.h) : 0) * SQMM_TO_SQFT },
                    { item: "Duco Paint (for Pattern)", unit: "SqFt", rate: RAW_MATERIAL_RATES.DUCO_PAINT, wastage: 15, calculateBaseQty: (f) => !['Header', 'Side Portals'].includes(f.item) || f.l < 50 ? 0 : (f.l * f.h * 1.5) * SQMM_TO_SQFT },
                    { item: "PVC Edge Banding (25mm)", unit: "RFt", rate: RAW_MATERIAL_RATES.PVC_EDGE_BAND_25MM, wastage: 0, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth', 'Shelves', 'Drawers'].includes(f.item) ? (2 * (f.l + f.w)) * MM_TO_FT : 0 },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE, wastage: 0, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS, wastage: 0, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM, wastage: 0, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET, wastage: 0, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST, wastage: 0, calculateBaseQty: (f) => { const r = 25, s = 50; if (f.item === 'Channels') return ((2 * (f.l + f.w) * f.h) * SQMM_TO_SQFT) * s; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return 0; } },
                    { item: "Finished 3D Acrylic Signage", unit: "SqFt", rate: RAW_MATERIAL_RATES.ACRYLIC_SIGNAGE_SQFT, wastage: 0, calculateBaseQty: (f) => f.item === 'Signage' ? (600 * 300) * SQMM_TO_SQFT : 0 },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE, wastage: 0, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? f.l * MM_TO_FT : 0 },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K, wastage: 0, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? f.l * MM_TO_FT : 0 },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM, wastage: 0, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? 3.28 : 0 },
                    { item: "1.5mm Wire (for driver)", unit: "Meter", rate: RAW_MATERIAL_RATES.WIRE_1_5MM, wastage: 0, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? 0.8 : 0 },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER, wastage: 0, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? 0.2 : 0 }
                ]
            },
            "Park Avenue": {
                materials: [
                    { item: "18mm MDF BSL (Charcoal/Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE, wastage: 15, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth', 'Drawers', 'Back Panels', 'Shelves'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "25x25mm AL Pipe (for Pattern)", unit: "RFt", rate: RAW_MATERIAL_RATES.AL_PIPE_50X50, wastage: 0, calculateBaseQty: (f) => { if (!['Header', 'Side Portals'].includes(f.item) || f.l < 50) return 0; return (Math.ceil(f.h / 50.4) * f.l) * MM_TO_FT; } },
                    { item: "PVC Edge Banding (25mm)", unit: "RFt", rate: RAW_MATERIAL_RATES.PVC_EDGE_BAND_25MM, wastage: 0, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth', 'Shelves', 'Drawers', 'Back Panels'].includes(f.item) ? (2 * (f.l + f.w)) * MM_TO_FT : 0 },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE, wastage: 0, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS, wastage: 0, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM, wastage: 0, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET, wastage: 0, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST, wastage: 0, calculateBaseQty: (f) => { const r = 25, s = 50; if (f.item === 'Channels') return ((2 * (f.l + f.w) * f.h) * SQMM_TO_SQFT) * s; if (['Header', 'Side Portals'].includes(f.item)) return ((Math.ceil(f.h / 50.4) * f.l) * MM_TO_FT) * r; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return 0; } },
                    { item: "Finished 3D Acrylic Signage", unit: "SqFt", rate: RAW_MATERIAL_RATES.ACRYLIC_SIGNAGE_SQFT, wastage: 0, calculateBaseQty: (f) => f.item === 'Signage' ? (600 * 300) * SQMM_TO_SQFT : 0 },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE, wastage: 0, calculateBaseQty: (f, o) => { if ((o.shelfType === 'lit' && f.item === 'Shelves') || f.item === 'Header') return f.l * MM_TO_FT; if (f.item === 'Side Portals') return f.h * MM_TO_FT; return 0; } },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K, wastage: 0, calculateBaseQty: (f, o) => { if ((o.shelfType === 'lit' && f.item === 'Shelves') || f.item === 'Header') return f.l * MM_TO_FT; if (f.item === 'Side Portals') return f.h * MM_TO_FT; return 0; } },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM, wastage: 0, calculateBaseQty: (f, o) => (o.shelfType === 'lit' && f.item === 'Shelves') || ['Header', 'Side Portals'].includes(f.item) ? 3.28 : 0 },
                    { item: "1.5mm Wire (for driver)", unit: "Meter", rate: RAW_MATERIAL_RATES.WIRE_1_5MM, wastage: 0, calculateBaseQty: (f, o) => { if (o.shelfType === 'lit' && f.item === 'Shelves') return 0.8; if (['Header', 'Side Portals'].includes(f.item)) return 2.0; return 0; } },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER, wastage: 0, calculateBaseQty: (f, o) => { if (o.shelfType === 'lit' && f.item === 'Shelves') return 0.2; if (['Header', 'Side Portals'].includes(f.item)) return 1.0; return 0; } }
                ]
            },
            "Ready to Wear": {
                materials: [
                    { item: "18mm MDF OSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_OSL_OWHITE, wastage: 15, calculateBaseQty: (f) => ['Header', 'Back Panels'].includes(f.item) ? (f.l * f.h) * SQMM_TO_SQFT : 0 },
                    { item: "18mm MDF BSL (Black)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_BLACK, wastage: 15, calculateBaseQty: (f) => f.item === 'Side Portals' ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "18mm MDF BSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE, wastage: 15, calculateBaseQty: (f) => ['Drawers', 'Plinth', 'Shelves'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "Cherry Walnut Laminate", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_CHERRY_WALNUT, wastage: 15, calculateBaseQty: (f) => { let a = 0; if (f.item === 'Header') a = (2 * (f.l * f.h + f.l * f.w)); if (f.item === 'Shelves') a = 2 * (f.l * f.w); if (f.item === 'Drawers') a = (f.l * f.h + f.l * f.w + 2 * f.w * f.h); if (f.item === 'Plinth') a = (2 * (f.l * f.h + f.l * f.w)); return a * SQMM_TO_SQFT; } },
                    { item: "Denim Splash Laminate", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_DENIM_SPLASH, wastage: 15, calculateBaseQty: (f) => f.item === 'Back Panels' ? (f.l * f.h) * SQMM_TO_SQFT : 0 },
                    { item: "25x25mm MS Pipe", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_25X25, wastage: 15, calculateBaseQty: (f) => f.item === 'Header' ? ((2 * (f.l + f.h)) * MM_TO_FT) * 0.43 : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST, wastage: 0, calculateBaseQty: (f) => { const r = 25; if (['Header', 'Side Portals', 'Channels'].includes(f.item)) return (f.h * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return 0; } },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? f.h * MM_TO_FT : 0 },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? f.h * MM_TO_FT : 0 },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? 3.28 : 0 },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? 1 : 0 },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE, wastage: 0, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS, wastage: 0, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM, wastage: 0, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET, wastage: 0, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                ]
            },
            "ColorPlus": {
                materials: [
                    { item: "18mm Prelam BSL Misty Pine Oak", unit: "SqFt", rate: RAW_MATERIAL_RATES.PRELAM_18_BSL_PINE_OAK, wastage: 15, calculateBaseQty: (f) => { let a = 0; if (['Header', 'Side Portals', 'Plinth'].includes(f.item)) a = (2 * (f.l * f.w + f.l * f.h + f.w * f.h)); if (f.item === 'Header') a += 2 * (2 * (f.l * 50 + f.l * 40 + 50 * 40)); return a * SQMM_TO_SQFT; } },
                    { item: "18mm MDF BSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE, wastage: 15, calculateBaseQty: (f) => ['Shelves', 'Drawers'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "Misty Pine Oak Laminate", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_PINE_OAK, wastage: 15, calculateBaseQty: (f) => f.item === 'Drawers' ? (f.l * f.w) * SQMM_TO_SQFT : 0 },
                    { item: "50x50mm AL Pipe", unit: "RFt", rate: RAW_MATERIAL_RATES.AL_PIPE_50X50, wastage: 15, calculateBaseQty: (f) => f.item === 'Header' ? (Math.ceil(f.l / 70) * 40) * MM_TO_FT : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST, wastage: 0, calculateBaseQty: (f) => { const r = 25; let c = 0; if (f.item === 'Header') c += ((Math.ceil(f.l / 70) * 40) * MM_TO_FT) * r; if (f.item === 'Channels') c += (f.h * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return c; } },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? f.h * MM_TO_FT : 0 },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? f.h * MM_TO_FT : 0 },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? 3.28 : 0 },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER, wastage: 0, calculateBaseQty: (f) => f.item === 'Side Portals' ? 1 : 0 },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE, wastage: 0, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS, wastage: 0, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM, wastage: 0, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET, wastage: 0, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                ]
            }
        });


        // --- DOM ELEMENTS ---
        const brandSelect = document.getElementById('brand-select');
        const generateBtn = document.getElementById('generate-btn');
        const loadingStatus = document.getElementById('loading-status');
        const recipesOutput = document.getElementById('recipes-output');


        // --- DATA LOADING & INITIALIZATION ---
        window.addEventListener('DOMContentLoaded', initializeApp);

        async function initializeApp() {
            try {
                const [rateContractResponse, materialRatesResponse] = await Promise.all([
                    fetch('rate_contract.csv'),
                    fetch('raw_material_rates.csv')
                ]);

                if (!rateContractResponse.ok) throw new Error(`HTTP error fetching rate_contract.csv: ${rateContractResponse.status}`);
                if (!materialRatesResponse.ok) throw new Error(`HTTP error fetching raw_material_rates.csv: ${materialRatesResponse.status}`);

                const rateContractText = await rateContractResponse.text();
                const materialRatesText = await materialRatesResponse.text();

                // Process fixture rate contract data
                const parsedRateData = parseCSV(rateContractText);
                RATE_DATA_BY_BRAND = processRateData(parsedRateData);

                // Process raw material rate data
                const parsedMaterialData = parseCSV(materialRatesText);
                RAW_MATERIAL_RATES = processMaterialRates(parsedMaterialData);


                // Enable the form now that all data is loaded
                loadingStatus.textContent = 'Select a brand to generate its unit recipes.';
                loadingStatus.classList.remove('text-yellow-400');
                loadingStatus.classList.add('text-gray-400');
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Recipes';
                generateBtn.classList.remove('bg-blue-800', 'text-gray-400', 'cursor-not-allowed');
                generateBtn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white');

                generateBtn.addEventListener('click', () => {
                    const selectedBrand = brandSelect.value;
                    displayUnitRecipesForBrand(selectedBrand);
                });

            } catch (error) {
                loadingStatus.textContent = 'Error: Could not load data files. Please check CSV files and console.';
                loadingStatus.classList.add('text-red-400');
                console.error("Failed to load or process CSV files:", error);
            }
        }

        // --- CORE LOGIC ---
        function displayUnitRecipesForBrand(brand) {
            recipesOutput.innerHTML = ''; // Clear previous results
            const brandRateData = RATE_DATA_BY_BRAND[brand];
            const BOM_CONFIG = getBomData();
            const brandBomData = BOM_CONFIG[brand];

            if (!brandRateData || !brandBomData) {
                recipesOutput.innerHTML = `<p class="text-center text-red-400">No data available for brand: ${brand}</p>`;
                return;
            }

            let allRecipesHTML = '';

            // Loop through each item type in the rate contract (e.g., "SIDE PORTAL")
            for (const csvItemName in brandRateData) {
                const bomItemName = CSV_TO_BOM_ITEM_MAP[csvItemName];
                if (!bomItemName) continue;

                const rateItems = brandRateData[csvItemName];

                // Loop through each specific dimension of that item
                rateItems.forEach(rateItem => {
                    // Special handling for shelves to show both LIT and Non-LIT versions
                    if (bomItemName === 'Shelves') {
                        allRecipesHTML += generateRecipeCardHTML(brand, bomItemName, rateItem, brandBomData, { shelfType: 'non-lit' });
                        allRecipesHTML += generateRecipeCardHTML(brand, bomItemName, rateItem, brandBomData, { shelfType: 'lit' });
                    } else {
                        allRecipesHTML += generateRecipeCardHTML(brand, bomItemName, rateItem, brandBomData, { shelfType: 'non-lit' }); // Default option
                    }
                });
            }

            recipesOutput.innerHTML = allRecipesHTML;
        }


        function generateRecipeCardHTML(brand, bomItemName, rateItem, brandBomData, options) {
            const fixture = { item: bomItemName, l: rateItem.l, w: rateItem.w, h: rateItem.h };
            let rowsHTML = '';
            let totalCost = 0;

            brandBomData.materials.forEach(mat => {
                const baseQty = mat.calculateBaseQty(fixture, options);
                if (baseQty > 0) {
                    const finalQty = baseQty * (1 + mat.wastage / 100);
                    const amount = finalQty * mat.rate;
                    totalCost += amount;
                    rowsHTML += `
                        <tr class="border-b border-gray-700">
                            <td class="p-2">${mat.item}</td>
                            <td class="p-2 text-right">${baseQty.toFixed(2)}</td>
                            <td class="p-2 text-center">${mat.unit}</td>
                            <td class="p-2 text-right">${mat.wastage.toFixed(2)}%</td>
                            <td class="p-2 text-right">${finalQty.toFixed(2)}</td>
                            <td class="p-2 text-right">${mat.rate.toFixed(2)}</td>
                            <td class="p-2 text-right font-medium">₹ ${amount.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                        </tr>`;
                }
            });

            if (!rowsHTML) return ''; // Don't generate a card if there are no materials

            let title = `${bomItemName} (${fixture.l}L x ${fixture.w}W x ${fixture.h}H mm)`;
            if (bomItemName === 'Shelves') {
                title += ` <span class="text-sm font-semibold uppercase ${options.shelfType === 'lit' ? 'text-yellow-400' : 'text-gray-400'}">${options.shelfType}</span>`;
            }

            return `
            <div class="bg-gray-800 rounded-xl shadow-lg overflow-hidden recipe-card">
                <h3 class="text-xl font-bold bg-gray-700 p-4">${title}</h3>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="border-b border-gray-600 bg-gray-700/50">
                                <th class="p-2 text-left font-semibold w-2/5">Material</th>
                                <th class="p-2 text-right font-semibold">Base Qty</th>
                                <th class="p-2 text-center font-semibold">Unit</th>
                                <th class="p-2 text-right font-semibold">Wastage</th>
                                <th class="p-2 text-right font-semibold">Final Qty</th>
                                <th class="p-2 text-right font-semibold">Rate (₹)</th>
                                <th class="p-2 text-right font-semibold">Amount (₹)</th>
                            </tr>
                        </thead>
                        <tbody>${rowsHTML}</tbody>
                    </table>
                </div>
                <div class="bg-gray-700 p-3 text-right">
                    <span class="text-gray-300 font-medium">Total Material Cost per Item:</span>
                    <span class="text-lg font-bold ml-2">₹ ${totalCost.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                </div>
            </div>`;
        }


        // --- UTILITY FUNCTIONS ---
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length === headers.length) {
                    const entry = {};
                    headers.forEach((header, index) => {
                        entry[header] = values[index];
                    });
                    data.push(entry);
                }
            }
            return data;
        }

        function processRateData(parsedData) {
            const groupedData = {};
            parsedData.forEach(row => {
                const { Brand, Item, L, W, H, FinalRate, ECPLRate } = row;
                if (!groupedData[Brand]) {
                    groupedData[Brand] = {};
                }
                const cleanItem = Item.toUpperCase();
                if (!groupedData[Brand][cleanItem]) {
                    groupedData[Brand][cleanItem] = [];
                }
                groupedData[Brand][cleanItem].push({
                    l: parseFloat(L),
                    w: parseFloat(W),
                    h: parseFloat(H),
                    finalRate: parseFloat(FinalRate),
                    ecplRate: parseFloat(ECPLRate)
                });
            });
            return groupedData;
        }

        function processMaterialRates(parsedData) {
            const rates = {};
            parsedData.forEach(row => {
                if (row.MaterialKey && row.Rate) {
                    rates[row.MaterialKey.trim()] = parseFloat(row.Rate);
                }
            });
            return rates;
        }
    </script>
</body>

</html>