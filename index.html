<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Recipe Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .recipe-card,
        .summary-section {
            page-break-inside: avoid;
        }

        @media print {
            body {
                background-color: #fff !important;
                color: #000 !important;
            }

            header,
            .input-form {
                display: none !important;
            }

            .recipe-card,
            .summary-section {
                box-shadow: none !important;
                border: 1px solid #ccc;
                margin-top: 1.5rem;
            }

            .recipe-card h3,
            .summary-section h2 {
                background-color: #eee !important;
                color: #000 !important;
            }

            .recipe-card table thead,
            .summary-section table thead {
                background-color: #f5f5f5 !important;
            }

            .recipe-card td,
            .recipe-card th,
            .summary-section td,
            .summary-section th {
                color: #000 !important;
                border-color: #ccc !important;
            }

            .recipe-card tfoot div,
            .summary-section tfoot div {
                background-color: #eee !important;
            }

            .text-yellow-400 {
                color: #000 !important;
            }

            .text-gray-400 {
                color: #555 !important;
            }

            .bg-gray-800 {
                background-color: #fff !important;
            }

            .bg-gray-700 {
                background-color: #eee !important;
            }

            .bg-gray-700\/50 {
                background-color: #f5f5f5 !important;
            }

            .border-gray-600 {
                border-color: #ccc !important;
            }

            .border-gray-700 {
                border-color: #ccc !important;
            }

            .text-gray-300 {
                color: #333 !important;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-white min-h-screen antialiased p-4 sm:p-6 md:p-8">

    <div class="w-full max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-white tracking-tight">Unit Recipe Generator v3 - with Summary</h1>
            <p id="loading-status" class="mt-2 text-lg text-yellow-400">Loading rate data...</p>
        </header>

        <!-- Input Form -->
        <div class="bg-gray-800 p-6 rounded-xl shadow-lg mb-8 max-w-2xl mx-auto input-form">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 items-end">
                <div class="md:col-span-2">
                    <label for="brand-select" class="block text-sm font-medium text-gray-300 mb-1">Select Brand</label>
                    <select id="brand-select"
                        class="w-full bg-gray-700 text-white border-gray-600 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 p-3">
                        <option value="Parx">Parx</option>
                        <option value="Park Avenue">Park Avenue</option>
                        <option value="Ready to Wear">Ready to Wear</option>
                        <option value="ColorPlus">ColorPlus</option>
                    </select>
                </div>
                <button type="button" id="generate-btn" disabled
                    class="w-full bg-blue-800 text-gray-400 font-bold py-3 px-4 rounded-lg shadow-md cursor-not-allowed">
                    Loading...
                </button>
            </div>
        </div>

        <!-- Recipes Output -->
        <div id="recipes-output" class="space-y-8">
            <!-- Unit recipes will be generated here -->
        </div>

        <!-- Summary Table Output -->
        <div id="summary-table-output" class="mt-12">
            <!-- Summary table will be generated here -->
        </div>

    </div>

    <script>
        // --- CONSTANTS & GLOBAL DATA ---
        const SQMM_TO_SQFT = (1 / 304.8) * (1 / 304.8);
        const MM_TO_FT = 1 / 304.8;
        let RATE_DATA_BY_BRAND = {};
        let RAW_MATERIAL_RATES = {}; // Now stores { rate: X, wastage: Y }

        const CSV_TO_BOM_ITEM_MAP = {
            "SIDE PORTAL": "Side Portals", "BACK PANEL": "Back Panels", "SHELVE": "Shelves",
            "DRAWER": "Drawers", "HEADER": "Header", "CHANNEL": "Channels",
            "PLINTH": "Plinth", "STRAIGHT ARM": "Straight Arm", "BACKBAR": "Backbar",
            "SHELF BRACKET": "Shelf Bracket"
        };


        // --- BILL OF MATERIALS CONFIGURATION (ALL BRANDS) ---
        // Accesses RAW_MATERIAL_RATES.MATERIAL_KEY.rate and .wastage
        const getBomData = () => ({
            "Parx": {
                materials: [
                    { item: "18mm MDF OSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_OSL_OWHITE.rate, wastage: RAW_MATERIAL_RATES.MDF_18_OSL_OWHITE.wastage, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : (f.item === 'Drawers' ? (f.l * f.w) + (f.l * f.h) : 0) * SQMM_TO_SQFT },
                    { item: "18mm MDF BSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.rate, wastage: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.wastage, calculateBaseQty: (f) => { let a = 0; if (f.item === 'Back Panels') a = (f.l * f.h); if (f.item === 'Drawers') a = (2 * f.w * f.h) + (f.l * f.h); if (f.item === 'Shelves') a = (f.l * f.w); return a * SQMM_TO_SQFT; } },
                    { item: "25mm MDF BSL (for Duco Pattern)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_25_BSL_DUCO.rate, wastage: RAW_MATERIAL_RATES.MDF_25_BSL_DUCO.wastage, calculateBaseQty: (f) => { if (f.item === 'Side Portals' && f.l < 51) return 0; return (['Header', 'Side Portals'].includes(f.item) && f.l >= 50) ? (f.l * f.h) * SQMM_TO_SQFT : 0 } }, // Added Parx Duco logic
                    { item: "Light Blue Laminate (1mm)", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_LIGHT_BLUE.rate, wastage: RAW_MATERIAL_RATES.LAMINATE_LIGHT_BLUE.wastage, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : (f.item === 'Drawers' ? (f.l * f.w) + (f.l * f.h) : 0) * SQMM_TO_SQFT },
                    { item: "Duco Paint (for Pattern)", unit: "SqFt", rate: RAW_MATERIAL_RATES.DUCO_PAINT.rate, wastage: RAW_MATERIAL_RATES.DUCO_PAINT.wastage, calculateBaseQty: (f) => { if (f.item === 'Side Portals' && f.l < 51) return 0; return !['Header', 'Side Portals'].includes(f.item) || f.l < 50 ? 0 : (f.l * f.h * 1.5) * SQMM_TO_SQFT } }, // Added Parx Duco logic
                    { item: "PVC Edge Banding (25mm)", unit: "RFt", rate: RAW_MATERIAL_RATES.PVC_EDGE_BAND_25MM.rate, wastage: RAW_MATERIAL_RATES.PVC_EDGE_BAND_25MM.wastage, calculateBaseQty: (f) => { let p = 0; if (['Header', 'Side Portals', 'Plinth', 'Shelves', 'Drawers'].includes(f.item)) p = (2 * (f.l + f.w)); if (f.item === 'Back Panels') p = (2 * (f.l + f.h)); return p * MM_TO_FT; } },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.wastage, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS.rate, wastage: RAW_MATERIAL_RATES.BACKCLIPS.wastage, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.rate, wastage: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.wastage, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.rate, wastage: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.wastage, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST.rate, wastage: RAW_MATERIAL_RATES.POWDER_COATING_COST.wastage, calculateBaseQty: (f) => { const r = 25, s = 50; if (f.item === 'Channels') return ((2 * (f.l + f.w) * f.h) * SQMM_TO_SQFT) * s; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return 0; } },
                    { item: "Finished 3D Acrylic Signage", unit: "SqFt", rate: RAW_MATERIAL_RATES.ACRYLIC_SIGNAGE_SQFT.rate, wastage: RAW_MATERIAL_RATES.ACRYLIC_SIGNAGE_SQFT.wastage, calculateBaseQty: (f) => f.item === 'Signage' ? (600 * 300) * SQMM_TO_SQFT : 0 },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.wastage, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? f.l * MM_TO_FT : 0 },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K.rate, wastage: RAW_MATERIAL_RATES.LED_STRIP_4000K.wastage, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? f.l * MM_TO_FT : 0 },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM.rate, wastage: RAW_MATERIAL_RATES.WIRE_1MM.wastage, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? 3.28 : 0 },
                    { item: "1.5mm Wire (for driver)", unit: "Meter", rate: RAW_MATERIAL_RATES.WIRE_1_5MM.rate, wastage: RAW_MATERIAL_RATES.WIRE_1_5MM.wastage, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? 0.8 : 0 },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER.rate, wastage: RAW_MATERIAL_RATES.LED_DRIVER.wastage, calculateBaseQty: (f, o) => o.shelfType === 'lit' && f.item === 'Shelves' ? 0.2 : 0 }
                ]
            },
            "Park Avenue": {
                materials: [
                    { item: "18mm MDF BSL (Charcoal/Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.rate, wastage: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.wastage, calculateBaseQty: (f) => ['Header', 'Side Portals', 'Plinth', 'Drawers', 'Back Panels', 'Shelves'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "25x25mm AL Pipe (for Pattern)", unit: "RFt", rate: RAW_MATERIAL_RATES.AL_PIPE_50X50.rate, wastage: RAW_MATERIAL_RATES.AL_PIPE_50X50.wastage, calculateBaseQty: (f) => { if (!['Header', 'Side Portals'].includes(f.item) || f.l < 50) return 0; return (Math.ceil(f.h / 50.4) * f.l) * MM_TO_FT; } },
                    { item: "PVC Edge Banding (25mm)", unit: "RFt", rate: RAW_MATERIAL_RATES.PVC_EDGE_BAND_25MM.rate, wastage: RAW_MATERIAL_RATES.PVC_EDGE_BAND_25MM.wastage, calculateBaseQty: (f) => { let p = 0; if (['Header', 'Side Portals', 'Plinth', 'Shelves', 'Drawers', 'Back Panels'].includes(f.item)) p = (2 * (f.l + f.w)); if (f.item === 'Back Panels') p = (2 * (f.l + f.h)); return p * MM_TO_FT; } },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.wastage, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS.rate, wastage: RAW_MATERIAL_RATES.BACKCLIPS.wastage, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.rate, wastage: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.wastage, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.rate, wastage: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.wastage, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST.rate, wastage: RAW_MATERIAL_RATES.POWDER_COATING_COST.wastage, calculateBaseQty: (f) => { const r = 25, s = 50; if (f.item === 'Channels') return ((2 * (f.l + f.w) * f.h) * SQMM_TO_SQFT) * s; if (['Header', 'Side Portals'].includes(f.item)) return ((Math.ceil(f.h / 50.4) * f.l) * MM_TO_FT) * r; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return 0; } },
                    { item: "Finished 3D Acrylic Signage", unit: "SqFt", rate: RAW_MATERIAL_RATES.ACRYLIC_SIGNAGE_SQFT.rate, wastage: RAW_MATERIAL_RATES.ACRYLIC_SIGNAGE_SQFT.wastage, calculateBaseQty: (f) => f.item === 'Signage' ? (600 * 300) * SQMM_TO_SQFT : 0 },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.wastage, calculateBaseQty: (f, o) => { if (f.item === 'Side Portals' && f.l === 18) return 0; if ((o.shelfType === 'lit' && f.item === 'Shelves') || f.item === 'Header') return f.l * MM_TO_FT; if (f.item === 'Side Portals') return f.h * MM_TO_FT; return 0; } },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K.rate, wastage: RAW_MATERIAL_RATES.LED_STRIP_4000K.wastage, calculateBaseQty: (f, o) => { if (f.item === 'Side Portals' && f.l === 18) return 0; if ((o.shelfType === 'lit' && f.item === 'Shelves') || f.item === 'Header') return f.l * MM_TO_FT; if (f.item === 'Side Portals') return f.h * MM_TO_FT; return 0; } },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM.rate, wastage: RAW_MATERIAL_RATES.WIRE_1MM.wastage, calculateBaseQty: (f, o) => { if (f.item === 'Side Portals' && f.l === 18) return 0; return (o.shelfType === 'lit' && f.item === 'Shelves') || ['Header', 'Side Portals'].includes(f.item) ? 3.28 : 0; } },
                    { item: "1.5mm Wire (for driver)", unit: "Meter", rate: RAW_MATERIAL_RATES.WIRE_1_5MM.rate, wastage: RAW_MATERIAL_RATES.WIRE_1_5MM.wastage, calculateBaseQty: (f, o) => { if (f.item === 'Side Portals' && f.l === 18) return 0; if (o.shelfType === 'lit' && f.item === 'Shelves') return 0.8; if (['Header', 'Side Portals'].includes(f.item)) return 2.0; return 0; } },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER.rate, wastage: RAW_MATERIAL_RATES.LED_DRIVER.wastage, calculateBaseQty: (f, o) => { if (f.item === 'Side Portals' && f.l === 18) return 0; if (o.shelfType === 'lit' && f.item === 'Shelves') return 0.2; if (['Header', 'Side Portals'].includes(f.item)) return 1.0; return 0; } }
                ]
            },
            "Ready to Wear": {
                materials: [
                    { item: "18mm MDF OSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_OSL_OWHITE.rate, wastage: RAW_MATERIAL_RATES.MDF_18_OSL_OWHITE.wastage, calculateBaseQty: (f) => ['Header', 'Back Panels'].includes(f.item) ? (f.l * f.h) * SQMM_TO_SQFT : 0 },
                    { item: "18mm MDF BSL (Black)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_BLACK.rate, wastage: RAW_MATERIAL_RATES.MDF_18_BSL_BLACK.wastage, calculateBaseQty: (f) => f.item === 'Side Portals' ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "18mm MDF BSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.rate, wastage: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.wastage, calculateBaseQty: (f) => ['Drawers', 'Plinth', 'Shelves'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "Cherry Walnut Laminate", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_CHERRY_WALNUT.rate, wastage: RAW_MATERIAL_RATES.LAMINATE_CHERRY_WALNUT.wastage, calculateBaseQty: (f) => { let a = 0; if (f.item === 'Header') a = (2 * (f.l * f.h + f.l * f.w)); if (f.item === 'Shelves') a = 2 * (f.l * f.w); if (f.item === 'Drawers') a = (f.l * f.h + f.l * f.w + 2 * f.w * f.h); if (f.item === 'Plinth') a = (2 * (f.l * f.h + f.l * f.w)); return a * SQMM_TO_SQFT; } },
                    { item: "Denim Splash Laminate", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_DENIM_SPLASH.rate, wastage: RAW_MATERIAL_RATES.LAMINATE_DENIM_SPLASH.wastage, calculateBaseQty: (f) => f.item === 'Back Panels' ? (f.l * f.h) * SQMM_TO_SQFT : 0 },
                    { item: "25x25mm MS Pipe", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_25X25.rate, wastage: RAW_MATERIAL_RATES.MS_PIPE_25X25.wastage, calculateBaseQty: (f) => f.item === 'Header' ? ((2 * (f.l + f.h)) * MM_TO_FT) * 0.43 : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST.rate, wastage: RAW_MATERIAL_RATES.POWDER_COATING_COST.wastage, calculateBaseQty: (f) => { const r = 25; if (f.item === 'Header') return (2 * (f.l + f.h)) * MM_TO_FT * r; if (f.item === 'Side Portals' && f.l !== 18) return (f.h * MM_TO_FT) * r; if (f.item === 'Channels') return (f.h * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return 0; } },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? f.h * MM_TO_FT : 0 },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K.rate, wastage: RAW_MATERIAL_RATES.LED_STRIP_4000K.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? f.h * MM_TO_FT : 0 },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM.rate, wastage: RAW_MATERIAL_RATES.WIRE_1MM.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? 3.28 : 0 },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER.rate, wastage: RAW_MATERIAL_RATES.LED_DRIVER.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? 1 : 0 },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.wastage, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS.rate, wastage: RAW_MATERIAL_RATES.BACKCLIPS.wastage, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.rate, wastage: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.wastage, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.rate, wastage: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.wastage, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                ]
            },
            "ColorPlus": {
                materials: [
                    { item: "18mm Prelam BSL Misty Pine Oak", unit: "SqFt", rate: RAW_MATERIAL_RATES.PRELAM_18_BSL_PINE_OAK.rate, wastage: RAW_MATERIAL_RATES.PRELAM_18_BSL_PINE_OAK.wastage, calculateBaseQty: (f) => { let a = 0; if (['Header', 'Side Portals', 'Plinth'].includes(f.item)) a = (2 * (f.l * f.w + f.l * f.h + f.w * f.h)); if (f.item === 'Header') a += 2 * (2 * (f.l * 50 + f.l * 40 + 50 * 40)); return a * SQMM_TO_SQFT; } },
                    { item: "18mm MDF BSL (Off-white)", unit: "SqFt", rate: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.rate, wastage: RAW_MATERIAL_RATES.MDF_18_BSL_OWHITE.wastage, calculateBaseQty: (f) => ['Shelves', 'Drawers'].includes(f.item) ? (2 * (f.l * f.w + f.l * f.h + f.w * f.h)) * SQMM_TO_SQFT : 0 },
                    { item: "Misty Pine Oak Laminate", unit: "SqFt", rate: RAW_MATERIAL_RATES.LAMINATE_PINE_OAK.rate, wastage: RAW_MATERIAL_RATES.LAMINATE_PINE_OAK.wastage, calculateBaseQty: (f) => f.item === 'Drawers' ? (f.l * f.w) * SQMM_TO_SQFT : 0 },
                    { item: "50x50mm AL Pipe", unit: "RFt", rate: RAW_MATERIAL_RATES.AL_PIPE_50X50.rate, wastage: RAW_MATERIAL_RATES.AL_PIPE_50X50.wastage, calculateBaseQty: (f) => f.item === 'Header' ? (Math.ceil(f.l / 70) * 40) * MM_TO_FT : 0 },
                    { item: "Powder Coating", unit: "Lump Sum Cost", rate: RAW_MATERIAL_RATES.POWDER_COATING_COST.rate, wastage: RAW_MATERIAL_RATES.POWDER_COATING_COST.wastage, calculateBaseQty: (f) => { const r = 25; let c = 0; if (f.item === 'Header') c += ((Math.ceil(f.l / 70) * 40) * MM_TO_FT) * r; if (f.item === 'Channels') c += (f.h * MM_TO_FT) * r; if (f.item === 'Straight Arm') return 4 * r; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * r; if (f.item === 'Shelf Bracket') return (350 * MM_TO_FT) * r; return c; } },
                    { item: "Aluminium LED Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_LED_PROFILE.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? f.h * MM_TO_FT : 0 },
                    { item: "LED Light Strip (4000K)", unit: "RFt", rate: RAW_MATERIAL_RATES.LED_STRIP_4000K.rate, wastage: RAW_MATERIAL_RATES.LED_STRIP_4000K.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? f.h * MM_TO_FT : 0 },
                    { item: "1mm Wire (for fixture)", unit: "RFt", rate: RAW_MATERIAL_RATES.WIRE_1MM.rate, wastage: RAW_MATERIAL_RATES.WIRE_1MM.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? 3.28 : 0 },
                    { item: "LED Driver", unit: "Nos", rate: RAW_MATERIAL_RATES.LED_DRIVER.rate, wastage: RAW_MATERIAL_RATES.LED_DRIVER.wastage, calculateBaseQty: (f) => (f.item === 'Side Portals' && f.l !== 18) ? 1 : 0 },
                    { item: "Aluminium Channel Profile", unit: "RFt", rate: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.rate, wastage: RAW_MATERIAL_RATES.ALUMINIUM_CHANNEL_PROFILE.wastage, calculateBaseQty: (f) => f.item === 'Channels' ? 8 : 0 },
                    { item: "Backclips for Accessories", unit: "Nos", rate: RAW_MATERIAL_RATES.BACKCLIPS.rate, wastage: RAW_MATERIAL_RATES.BACKCLIPS.wastage, calculateBaseQty: (f) => ['Straight Arm', 'Backbar'].includes(f.item) ? 2 : 0 },
                    { item: "MS Pipe (15x30mm, 2mm thk)", unit: "Kg", rate: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.rate, wastage: RAW_MATERIAL_RATES.MS_PIPE_15X30_2MM.wastage, calculateBaseQty: (f) => { const w = 0.43; if (f.item === 'Straight Arm') return 4 * w; if (f.item === 'Backbar') return (f.l * MM_TO_FT) * w; return 0; } },
                    { item: "MS Shelf Bracket Cost", unit: "Nos", rate: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.rate, wastage: RAW_MATERIAL_RATES.MS_SHELF_BRACKET.wastage, calculateBaseQty: (f) => f.item === 'Shelf Bracket' ? 1 : 0 },
                ]
            }
        });

        // --- DOM ELEMENTS ---
        const brandSelect = document.getElementById('brand-select');
        const generateBtn = document.getElementById('generate-btn');
        const loadingStatus = document.getElementById('loading-status');
        const recipesOutput = document.getElementById('recipes-output');
        const summaryTableOutput = document.getElementById('summary-table-output');


        // --- DATA LOADING & INITIALIZATION ---
        window.addEventListener('DOMContentLoaded', initializeApp);

        async function initializeApp() {
            try {
                const [rateContractResponse, materialRatesResponse] = await Promise.all([
                    fetch('rate_contract.csv'),
                    fetch('raw_material_rates.csv')
                ]);

                if (!rateContractResponse.ok) throw new Error(`HTTP error fetching rate_contract.csv: ${rateContractResponse.status}`);
                if (!materialRatesResponse.ok) throw new Error(`HTTP error fetching raw_material_rates.csv: ${materialRatesResponse.status}`);

                const rateContractText = await rateContractResponse.text();
                const materialRatesText = await materialRatesResponse.text();

                const parsedRateData = parseCSV(rateContractText);
                RATE_DATA_BY_BRAND = processRateData(parsedRateData);

                const parsedMaterialData = parseCSV(materialRatesText);
                RAW_MATERIAL_RATES = processMaterialRates(parsedMaterialData); // Now includes wastage


                loadingStatus.textContent = 'Select a brand to generate its unit recipes.';
                loadingStatus.classList.remove('text-yellow-400');
                loadingStatus.classList.add('text-gray-400');
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Recipes';
                generateBtn.classList.remove('bg-blue-800', 'text-gray-400', 'cursor-not-allowed');
                generateBtn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white');

                generateBtn.addEventListener('click', () => {
                    const selectedBrand = brandSelect.value;
                    displayUnitRecipesForBrand(selectedBrand);
                });

            } catch (error) {
                loadingStatus.textContent = 'Error: Could not load data files. Please check CSV files and console.';
                loadingStatus.classList.add('text-red-400');
                console.error("Failed to load or process CSV files:", error);
            }
        }

        // --- CORE LOGIC ---
        function displayUnitRecipesForBrand(brand) {
            recipesOutput.innerHTML = '';
            summaryTableOutput.innerHTML = '';
            const brandRateData = RATE_DATA_BY_BRAND[brand];
            const BOM_CONFIG = getBomData(); // Get BOM config with rates/wastage loaded
            const brandBomData = BOM_CONFIG[brand];

            if (!brandRateData || !brandBomData) {
                recipesOutput.innerHTML = `<p class="text-center text-red-400">No data available for brand: ${brand}</p>`;
                return;
            }

            let allRecipesHTML = '';
            let summaryData = [];

            for (const csvItemName in brandRateData) {
                const bomItemName = CSV_TO_BOM_ITEM_MAP[csvItemName];
                if (!bomItemName) continue;

                const rateItems = brandRateData[csvItemName];

                rateItems.forEach(rateItem => {
                    const processRecipe = (options) => {
                        const { html, summary } = generateRecipeCardHTML(brand, bomItemName, rateItem, brandBomData, options);
                        if (html) {
                            allRecipesHTML += html;
                            summaryData.push(summary);
                        }
                    };

                    if (bomItemName === 'Shelves') {
                        processRecipe({ shelfType: 'non-lit' });
                        processRecipe({ shelfType: 'lit' });
                    } else {
                        processRecipe({ shelfType: 'non-lit' }); // Pass default options
                    }
                });
            }

            recipesOutput.innerHTML = allRecipesHTML;
            summaryTableOutput.innerHTML = generateSummaryTableHTML(summaryData);
        }


        function generateRecipeCardHTML(brand, bomItemName, rateItem, brandBomData, options) {
            const fixture = { item: bomItemName, l: rateItem.l, w: rateItem.w, h: rateItem.h };
            let rowsHTML = '';
            let totalCost = 0;

            brandBomData.materials.forEach(mat => {
                // Ensure rate and wastage are numbers, default to 0 if not found
                const rate = mat.rate || 0;
                const wastage = mat.wastage || 0;

                const baseQty = mat.calculateBaseQty(fixture, options);
                if (baseQty > 0) {
                    const finalQty = baseQty * (1 + wastage / 100); // Use wastage from CSV
                    const amount = finalQty * rate;
                    totalCost += amount;
                    rowsHTML += `
                         <tr class="border-b border-gray-700">
                             <td class="p-2">${mat.item}</td>
                             <td class="p-2 text-right">${baseQty.toFixed(2)}</td>
                             <td class="p-2 text-center">${mat.unit}</td>
                             <td class="p-2 text-right">${wastage.toFixed(2)}%</td> {/* Display wastage from CSV */}
                             <td class="p-2 text-right">${finalQty.toFixed(2)}</td>
                             <td class="p-2 text-right">${rate.toFixed(2)}</td>
                             <td class="p-2 text-right font-medium">₹ ${amount.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                         </tr>`;
                }
            });

            if (!rowsHTML) return { html: '', summary: null };

            const sizeString = `(${fixture.l}L x ${fixture.w}W x ${fixture.h}H mm)`;
            let title = `${bomItemName} ${sizeString}`;
            let summaryName = title;
            if (bomItemName === 'Shelves') {
                const litStatus = options.shelfType === 'lit' ? 'LIT' : 'Non-LIT';
                title += ` <span class="text-sm font-semibold uppercase ${options.shelfType === 'lit' ? 'text-yellow-400' : 'text-gray-400'}">${litStatus}</span>`;
                summaryName += ` ${litStatus}`;
            }

            const html = `
            <div class="bg-gray-800 rounded-xl shadow-lg overflow-hidden recipe-card">
                <h3 class="text-xl font-bold bg-gray-700 p-4">${title}</h3>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="border-b border-gray-600 bg-gray-700/50">
                                <th class="p-2 text-left font-semibold w-2/5">Material</th>
                                <th class="p-2 text-right font-semibold">Base Qty</th>
                                <th class="p-2 text-center font-semibold">Unit</th>
                                <th class="p-2 text-right font-semibold">Wastage</th> {/* Changed label */}
                                <th class="p-2 text-right font-semibold">Final Qty</th>
                                <th class="p-2 text-right font-semibold">Rate (₹)</th>
                                <th class="p-2 text-right font-semibold">Amount (₹)</th>
                            </tr>
                        </thead>
                        <tbody>${rowsHTML}</tbody>
                    </table>
                </div>
                <div class="bg-gray-700 p-3 text-right">
                    <span class="text-gray-300 font-medium">Total Material Cost per Item:</span>
                    <span class="text-lg font-bold ml-2">₹ ${totalCost.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
                </div>
            </div>`;

            const summary = { name: summaryName, size: sizeString, cost: totalCost };
            return { html, summary };
        }

        function generateSummaryTableHTML(summaryData) {
            if (!summaryData || summaryData.length === 0) return '';

            let tableRowsHTML = '';
            summaryData.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically by name
            summaryData.forEach(item => {
                const amount = Math.round(item.cost * 2);
                tableRowsHTML += `
                     <tr class="border-b border-gray-700">
                         <td class="p-3">${item.name}</td>
                         <td class="p-3 text-right">₹ ${item.cost.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                         <td class="p-3 text-right font-semibold">₹ ${amount.toLocaleString('en-IN')}</td>
                     </tr>
                 `;
            });

            return `
             <div class="bg-gray-800 rounded-xl shadow-lg overflow-hidden summary-section">
                  <h2 class="text-2xl font-bold bg-gray-700 p-4">Summary</h2>
                  <div class="overflow-x-auto">
                      <table class="w-full">
                          <thead>
                              <tr class="border-b border-gray-600 bg-gray-700/50">
                                  <th class="p-3 text-left font-semibold w-1/2">Item Name & Size</th>
                                  <th class="p-3 text-right font-semibold">Total Material Cost (₹)</th>
                                  <th class="p-3 text-right font-semibold">Amount (₹)</th>
                              </tr>
                          </thead>
                          <tbody>
                              ${tableRowsHTML}
                          </tbody>
                      </table>
                  </div>
              </div>
             `;
        }


        // --- UTILITY FUNCTIONS ---
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 1) return [];
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length === headers.length) {
                    const entry = {};
                    headers.forEach((header, index) => {
                        entry[header] = values[index];
                    });
                    data.push(entry);
                } else {
                    console.warn(`Skipping line ${i + 1} due to incorrect number of columns.`);
                }
            }
            return data;
        }

        function processRateData(parsedData) {
            const groupedData = {};
            parsedData.forEach(row => {
                const { Brand, Item, L, W, H, FinalRate, ECPLRate } = row;
                if (!Brand || !Item) return;
                if (!groupedData[Brand]) groupedData[Brand] = {};
                const cleanItem = Item.toUpperCase();
                if (!groupedData[Brand][cleanItem]) groupedData[Brand][cleanItem] = [];
                groupedData[Brand][cleanItem].push({
                    l: parseFloat(L) || 0, w: parseFloat(W) || 0, h: parseFloat(H) || 0,
                    finalRate: parseFloat(FinalRate) || 0, ecplRate: parseFloat(ECPLRate) || 0
                });
            });
            return groupedData;
        }

        function processMaterialRates(parsedData) {
            const rates = {};
            parsedData.forEach(row => {
                // Expecting MaterialKey, Rate, Wastage columns
                if (row.MaterialKey && row.Rate && row.Wastage !== undefined) {
                    const key = row.MaterialKey.trim();
                    const rate = parseFloat(row.Rate) || 0;
                    const wastage = parseFloat(row.Wastage) || 0; // Default wastage to 0 if parsing fails
                    rates[key] = { rate: rate, wastage: wastage }; // Store as an object
                } else {
                    console.warn(`Skipping material rate row due to missing data: ${JSON.stringify(row)}`);
                }
            });
            // Check if essential rates were loaded
            if (!rates.MDF_18_OSL_OWHITE) console.error("CRITICAL: MDF_18_OSL_OWHITE rate not loaded!");
            return rates;
        }
    </script>
</body>

</html>